<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hoop Master Pro</title>
    <style>
        :root {
            --bg-color: #020617;
            --court-orange: #f97316;
            --miss-red: #ef4444;
            --ui-glass: rgba(255, 255, 255, 0.05);
            --ui-border: rgba(255, 255, 255, 0.1);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            background: radial-gradient(circle at 10% 20%, #1e293b 0%, #020617 100%);
        }

        #ui-layer {
            position: absolute;
            top: 30px;
            left: 30px;
            right: 30px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .stats-container {
            display: flex;
            gap: 15px;
        }

        .stat-card {
            background: var(--ui-glass);
            padding: 12px 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid var(--ui-border);
            color: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            min-width: 100px;
        }

        .stat-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0.5;
            margin-bottom: 2px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 800;
        }

        #score-val { color: var(--court-orange); }
        #miss-val { color: var(--miss-red); }

        .actions-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }

        .btn {
            background: var(--ui-glass);
            border: 1px solid var(--ui-border);
            color: white;
            padding: 10px 24px;
            border-radius: 14px;
            font-weight: bold;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 12px;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
            border-color: var(--court-orange);
            color: var(--court-orange);
        }

        .btn:active {
            transform: translateY(0);
        }

        #toast {
            position: absolute;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 64px;
            font-weight: 900;
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-shadow: 0 0 30px rgba(249, 115, 22, 0.6);
        }

        .hint {
            position: absolute;
            bottom: 30px;
            color: rgba(255,255,255,0.3);
            font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="stats-container">
            <div class="stat-card">
                <div class="stat-label">Score</div>
                <div id="score-val" class="stat-value">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Misses</div>
                <div id="miss-val" class="stat-value">0</div>
            </div>
        </div>
        
        <div class="actions-container">
            <button id="restart-btn" class="btn">Restart</button>
        </div>
    </div>

    <div id="toast">SWISH!</div>
    <div class="hint">Drag the ball to aim and shoot</div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score-val');
    const missEl = document.getElementById('miss-val');
    const toastEl = document.getElementById('toast');
    const restartBtn = document.getElementById('restart-btn');

    // Game Physics constants
    const GRAVITY = 0.35;
    const BOUNCE = 0.75; 
    const AIR_RESISTANCE = 0.995;

    let score = 0;
    let misses = 0;
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let dragCurrent = { x: 0, y: 0 };

    const ball = {
        x: 0,
        y: 0,
        radius: 24,
        vx: 0,
        vy: 0,
        angle: 0,
        rotationSpeed: 0,
        isFlying: false,
        reset: function(isManualReset = false) {
            // Automatic miss detection: if it wasn't scored and it was flying, increment misses
            if (!isManualReset && this.isFlying && !hoop.hasScoredThisTurn) {
                incrementMiss();
            }
            this.x = 100;
            this.y = canvas.height - 150;
            this.vx = 0;
            this.vy = 0;
            this.angle = 0;
            this.rotationSpeed = 0;
            this.isFlying = false;
            hoop.hasScoredThisTurn = false;
        }
    };

    const hoop = {
        x: 0, y: 0, width: 85,
        rimThickness: 10,
        backboardX: 0, backboardY: 0,
        backboardW: 12, backboardH: 140,
        hasScoredThisTurn: false,
        init: function() {
            this.backboardX = canvas.width - this.backboardW;
            this.y = canvas.height * 0.35;
            this.x = this.backboardX - (this.width / 2) - 5;
            this.backboardY = this.y - 110;
        }
    };

    function incrementMiss() {
        misses++;
        missEl.innerText = misses;
    }

    function init() {
        resize();
        ball.reset(true);
        
        window.addEventListener('resize', resize);
        
        restartBtn.addEventListener('click', () => {
            score = 0;
            misses = 0;
            scoreEl.innerText = 0;
            missEl.innerText = 0;
            ball.reset(true);
            showToast("RESTARTED");
        });

        canvas.addEventListener('mousedown', startDrag);
        window.addEventListener('mousemove', moveDrag);
        window.addEventListener('mouseup', endDrag);

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startDrag(e.touches[0]);
        }, { passive: false });
        window.addEventListener('touchmove', (e) => moveDrag(e.touches[0]));
        window.addEventListener('touchend', endDrag);

        requestAnimationFrame(gameLoop);
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        hoop.init();
        if (!ball.isFlying) ball.reset(true);
    }

    function startDrag(e) {
        if (ball.isFlying) return;
        const dist = Math.hypot(e.clientX - ball.x, e.clientY - ball.y);
        if (dist < 100) {
            isDragging = true;
            dragStart = { x: ball.x, y: ball.y };
            dragCurrent = { x: e.clientX, y: e.clientY };
        }
    }

    function moveDrag(e) {
        if (!isDragging) return;
        dragCurrent = { x: e.clientX, y: e.clientY };
    }

    function endDrag() {
        if (!isDragging) return;
        isDragging = false;
        const dx = dragCurrent.x - dragStart.x;
        const dy = dragCurrent.y - dragStart.y;
        ball.vx = dx * 0.14;
        ball.vy = dy * 0.14;
        ball.rotationSpeed = ball.vx * 0.05;
        if (Math.abs(ball.vx) + Math.abs(ball.vy) > 2) ball.isFlying = true;
    }

    function showToast(text) {
        toastEl.innerText = text;
        toastEl.style.opacity = '1';
        toastEl.style.transform = 'translate(-50%, -50%) scale(1.1)';
        setTimeout(() => {
            toastEl.style.opacity = '0';
            toastEl.style.transform = 'translate(-50%, -50%) scale(1)';
        }, 1000);
    }

    function resolveRimCollision(px, py) {
        const dist = Math.hypot(ball.x - px, ball.y - py);
        if (dist < ball.radius + hoop.rimThickness / 2) {
            const nx = (ball.x - px) / dist;
            const ny = (ball.y - py) / dist;
            const dot = ball.vx * nx + ball.vy * ny;
            if (dot < 0) {
                ball.vx = (ball.vx - 2 * dot * nx) * BOUNCE;
                ball.vy = (ball.vy - 2 * dot * ny) * BOUNCE;
                ball.vx += nx * 1.5; ball.vy += ny * 1.5; // Physical kick
                ball.x = px + nx * (ball.radius + hoop.rimThickness / 2 + 2);
                ball.y = py + ny * (ball.radius + hoop.rimThickness / 2 + 2);
            }
        }
    }

    function update() {
        if (!ball.isFlying) return;

        ball.vy += GRAVITY;
        ball.vx *= AIR_RESISTANCE;
        ball.x += ball.vx;
        ball.y += ball.vy;
        ball.angle += ball.rotationSpeed;

        if (ball.x + ball.radius > hoop.backboardX && 
            ball.y > hoop.backboardY && ball.y < hoop.backboardY + hoop.backboardH) {
            ball.vx = -Math.abs(ball.vx) * BOUNCE;
            ball.x = hoop.backboardX - ball.radius - 2;
        }

        resolveRimCollision(hoop.x - hoop.width / 2, hoop.y);
        resolveRimCollision(hoop.x + hoop.width / 2, hoop.y);

        if (!hoop.hasScoredThisTurn && ball.vy > 0) {
            if (ball.x > hoop.x - hoop.width/2 && ball.x < hoop.x + hoop.width/2 && 
                ball.y > hoop.y - 15 && ball.y < hoop.y + 15) {
                hoop.hasScoredThisTurn = true;
                score++;
                scoreEl.innerText = score;
                showToast("SWISH!");
            }
        }

        if (ball.y > canvas.height + 100 || ball.x > canvas.width + 100 || ball.x < -100) {
            ball.reset();
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "rgba(255,255,255,0.05)";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(0, canvas.height - 80); ctx.lineTo(canvas.width, canvas.height - 80);
        ctx.stroke();

        // Hoop Assembly
        ctx.fillStyle = "rgba(255, 255, 255, 0.08)";
        ctx.strokeStyle = "rgba(255, 255, 255, 0.4)";
        ctx.fillRect(hoop.backboardX, hoop.backboardY, hoop.backboardW, hoop.backboardH);
        ctx.strokeRect(hoop.backboardX, hoop.backboardY, hoop.backboardW, hoop.backboardH);
        ctx.strokeRect(hoop.backboardX - 2, hoop.y - 45, 5, 60);

        // Net
        ctx.beginPath();
        ctx.strokeStyle = "rgba(255,255,255,0.25)";
        ctx.lineWidth = 1;
        const rimL = hoop.x - hoop.width/2;
        for(let i=0; i<=5; i++) {
            ctx.moveTo(rimL + (i * (hoop.width/5)), hoop.y);
            ctx.lineTo(hoop.x - 15 + (i*6), hoop.y + 55);
        }
        ctx.stroke();

        // Rim
        ctx.beginPath();
        ctx.strokeStyle = "#ef4444";
        ctx.lineWidth = hoop.rimThickness;
        ctx.moveTo(hoop.x - hoop.width/2, hoop.y);
        ctx.lineTo(hoop.x + hoop.width/2, hoop.y);
        ctx.stroke();

        // Trajectory Preview
        if (isDragging) {
            ctx.beginPath();
            ctx.strokeStyle = "rgba(255,255,255,0.15)";
            ctx.setLineDash([4, 12]);
            let tx = ball.x, ty = ball.y;
            let tvx = (dragCurrent.x - dragStart.x) * 0.14, tvy = (dragCurrent.y - dragStart.y) * 0.14;
            ctx.moveTo(tx, ty);
            for(let i=0; i<25; i++) {
                tvy += GRAVITY; tx += tvx; ty += tvy;
                ctx.lineTo(tx, ty);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // The Ball
        ctx.save();
        ctx.translate(ball.x, ball.y);
        ctx.rotate(ball.angle);
        const grad = ctx.createRadialGradient(-5,-5, 5, 0, 0, ball.radius);
        grad.addColorStop(0, "#fb923c"); grad.addColorStop(1, "#c2410c");
        ctx.beginPath(); ctx.arc(0, 0, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = grad; ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-ball.radius, 0); ctx.lineTo(ball.radius, 0);
        ctx.moveTo(0, -ball.radius); ctx.lineTo(0, ball.radius);
        ctx.ellipse(0, 0, ball.radius, ball.radius * 0.6, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    init();
</script>
</body>
</html>
